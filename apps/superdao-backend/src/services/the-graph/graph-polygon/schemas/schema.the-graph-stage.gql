"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity
is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

type AdminOption {
  id: ID!
  user: User
  controller: Controller!
}

input AdminOption_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_: User_filter
  controller: String
  controller_not: String
  controller_gt: String
  controller_lt: String
  controller_gte: String
  controller_lte: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_contains: String
  controller_contains_nocase: String
  controller_not_contains: String
  controller_not_contains_nocase: String
  controller_starts_with: String
  controller_starts_with_nocase: String
  controller_not_starts_with: String
  controller_not_starts_with_nocase: String
  controller_ends_with: String
  controller_ends_with_nocase: String
  controller_not_ends_with: String
  controller_not_ends_with_nocase: String
  controller_: Controller_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum AdminOption_orderBy {
  id
  user
  controller
}

type Attribute {
  id: ID!
  key: String
  value: String
  propertyKey: String
  propertyValue: String
  tier: Tier!
}

input Attribute_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: String
  key_not: String
  key_gt: String
  key_lt: String
  key_gte: String
  key_lte: String
  key_in: [String!]
  key_not_in: [String!]
  key_contains: String
  key_contains_nocase: String
  key_not_contains: String
  key_not_contains_nocase: String
  key_starts_with: String
  key_starts_with_nocase: String
  key_not_starts_with: String
  key_not_starts_with_nocase: String
  key_ends_with: String
  key_ends_with_nocase: String
  key_not_ends_with: String
  key_not_ends_with_nocase: String
  value: String
  value_not: String
  value_gt: String
  value_lt: String
  value_gte: String
  value_lte: String
  value_in: [String!]
  value_not_in: [String!]
  value_contains: String
  value_contains_nocase: String
  value_not_contains: String
  value_not_contains_nocase: String
  value_starts_with: String
  value_starts_with_nocase: String
  value_not_starts_with: String
  value_not_starts_with_nocase: String
  value_ends_with: String
  value_ends_with_nocase: String
  value_not_ends_with: String
  value_not_ends_with_nocase: String
  propertyKey: String
  propertyKey_not: String
  propertyKey_gt: String
  propertyKey_lt: String
  propertyKey_gte: String
  propertyKey_lte: String
  propertyKey_in: [String!]
  propertyKey_not_in: [String!]
  propertyKey_contains: String
  propertyKey_contains_nocase: String
  propertyKey_not_contains: String
  propertyKey_not_contains_nocase: String
  propertyKey_starts_with: String
  propertyKey_starts_with_nocase: String
  propertyKey_not_starts_with: String
  propertyKey_not_starts_with_nocase: String
  propertyKey_ends_with: String
  propertyKey_ends_with_nocase: String
  propertyKey_not_ends_with: String
  propertyKey_not_ends_with_nocase: String
  propertyValue: String
  propertyValue_not: String
  propertyValue_gt: String
  propertyValue_lt: String
  propertyValue_gte: String
  propertyValue_lte: String
  propertyValue_in: [String!]
  propertyValue_not_in: [String!]
  propertyValue_contains: String
  propertyValue_contains_nocase: String
  propertyValue_not_contains: String
  propertyValue_not_contains_nocase: String
  propertyValue_starts_with: String
  propertyValue_starts_with_nocase: String
  propertyValue_not_starts_with: String
  propertyValue_not_starts_with_nocase: String
  propertyValue_ends_with: String
  propertyValue_ends_with_nocase: String
  propertyValue_not_ends_with: String
  propertyValue_not_ends_with_nocase: String
  tier: String
  tier_not: String
  tier_gt: String
  tier_lt: String
  tier_gte: String
  tier_lte: String
  tier_in: [String!]
  tier_not_in: [String!]
  tier_contains: String
  tier_contains_nocase: String
  tier_not_contains: String
  tier_not_contains_nocase: String
  tier_starts_with: String
  tier_starts_with_nocase: String
  tier_not_starts_with: String
  tier_not_starts_with_nocase: String
  tier_ends_with: String
  tier_ends_with_nocase: String
  tier_not_ends_with: String
  tier_not_ends_with_nocase: String
  tier_: Tier_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Attribute_orderBy {
  id
  key
  value
  propertyKey
  propertyValue
  tier
}

scalar BigDecimal

scalar BigInt

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

input BlockChangedFilter {
  number_gte: Int!
}

scalar Bytes

type Collection {
  id: ID!
  isNative: Boolean!
  name: String
  symbol: String
  url: String
  openseaOwner: Bytes
  nfts(skip: Int = 0, first: Int = 100, orderBy: Nft_orderBy, orderDirection: OrderDirection, where: Nft_filter): [Nft!]
  tiers(skip: Int = 0, first: Int = 100, orderBy: Tier_orderBy, orderDirection: OrderDirection, where: Tier_filter): [Tier!]
}

input Collection_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isNative: Boolean
  isNative_not: Boolean
  isNative_in: [Boolean!]
  isNative_not_in: [Boolean!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  url: String
  url_not: String
  url_gt: String
  url_lt: String
  url_gte: String
  url_lte: String
  url_in: [String!]
  url_not_in: [String!]
  url_contains: String
  url_contains_nocase: String
  url_not_contains: String
  url_not_contains_nocase: String
  url_starts_with: String
  url_starts_with_nocase: String
  url_not_starts_with: String
  url_not_starts_with_nocase: String
  url_ends_with: String
  url_ends_with_nocase: String
  url_not_ends_with: String
  url_not_ends_with_nocase: String
  openseaOwner: Bytes
  openseaOwner_not: Bytes
  openseaOwner_in: [Bytes!]
  openseaOwner_not_in: [Bytes!]
  openseaOwner_contains: Bytes
  openseaOwner_not_contains: Bytes
  nfts_: Nft_filter
  tiers_: Tier_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Collection_orderBy {
  id
  isNative
  name
  symbol
  url
  openseaOwner
  nfts
  tiers
}

type Controller {
  id: ID!
  admins(skip: Int = 0, first: Int = 100, orderBy: AdminOption_orderBy, orderDirection: OrderDirection, where: AdminOption_filter): [AdminOption!]!
}

input Controller_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  admins_: AdminOption_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Controller_orderBy {
  id
  admins
}

type Dao {
  id: ID!
  controller: Controller!
  collection: Collection
  openSale: OpenSaleApp
  privateSale: PrivateSaleApp
  treasury: Bytes
  safes: [Bytes!]
}

input Dao_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  controller: String
  controller_not: String
  controller_gt: String
  controller_lt: String
  controller_gte: String
  controller_lte: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_contains: String
  controller_contains_nocase: String
  controller_not_contains: String
  controller_not_contains_nocase: String
  controller_starts_with: String
  controller_starts_with_nocase: String
  controller_not_starts_with: String
  controller_not_starts_with_nocase: String
  controller_ends_with: String
  controller_ends_with_nocase: String
  controller_not_ends_with: String
  controller_not_ends_with_nocase: String
  controller_: Controller_filter
  collection: String
  collection_not: String
  collection_gt: String
  collection_lt: String
  collection_gte: String
  collection_lte: String
  collection_in: [String!]
  collection_not_in: [String!]
  collection_contains: String
  collection_contains_nocase: String
  collection_not_contains: String
  collection_not_contains_nocase: String
  collection_starts_with: String
  collection_starts_with_nocase: String
  collection_not_starts_with: String
  collection_not_starts_with_nocase: String
  collection_ends_with: String
  collection_ends_with_nocase: String
  collection_not_ends_with: String
  collection_not_ends_with_nocase: String
  collection_: Collection_filter
  openSale: String
  openSale_not: String
  openSale_gt: String
  openSale_lt: String
  openSale_gte: String
  openSale_lte: String
  openSale_in: [String!]
  openSale_not_in: [String!]
  openSale_contains: String
  openSale_contains_nocase: String
  openSale_not_contains: String
  openSale_not_contains_nocase: String
  openSale_starts_with: String
  openSale_starts_with_nocase: String
  openSale_not_starts_with: String
  openSale_not_starts_with_nocase: String
  openSale_ends_with: String
  openSale_ends_with_nocase: String
  openSale_not_ends_with: String
  openSale_not_ends_with_nocase: String
  openSale_: OpenSaleApp_filter
  privateSale: String
  privateSale_not: String
  privateSale_gt: String
  privateSale_lt: String
  privateSale_gte: String
  privateSale_lte: String
  privateSale_in: [String!]
  privateSale_not_in: [String!]
  privateSale_contains: String
  privateSale_contains_nocase: String
  privateSale_not_contains: String
  privateSale_not_contains_nocase: String
  privateSale_starts_with: String
  privateSale_starts_with_nocase: String
  privateSale_not_starts_with: String
  privateSale_not_starts_with_nocase: String
  privateSale_ends_with: String
  privateSale_ends_with_nocase: String
  privateSale_not_ends_with: String
  privateSale_not_ends_with_nocase: String
  privateSale_: PrivateSaleApp_filter
  treasury: Bytes
  treasury_not: Bytes
  treasury_in: [Bytes!]
  treasury_not_in: [Bytes!]
  treasury_contains: Bytes
  treasury_not_contains: Bytes
  safes: [Bytes!]
  safes_not: [Bytes!]
  safes_contains: [Bytes!]
  safes_contains_nocase: [Bytes!]
  safes_not_contains: [Bytes!]
  safes_not_contains_nocase: [Bytes!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Dao_orderBy {
  id
  controller
  collection
  openSale
  privateSale
  treasury
  safes
}

type Nft {
  id: ID!
  tokenID: BigInt!
  artworkID: Int
  transferredAt: BigInt
  tier: Tier
  owner: User!
  collection: Collection!
}

input Nft_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  tokenID: BigInt
  tokenID_not: BigInt
  tokenID_gt: BigInt
  tokenID_lt: BigInt
  tokenID_gte: BigInt
  tokenID_lte: BigInt
  tokenID_in: [BigInt!]
  tokenID_not_in: [BigInt!]
  artworkID: Int
  artworkID_not: Int
  artworkID_gt: Int
  artworkID_lt: Int
  artworkID_gte: Int
  artworkID_lte: Int
  artworkID_in: [Int!]
  artworkID_not_in: [Int!]
  transferredAt: BigInt
  transferredAt_not: BigInt
  transferredAt_gt: BigInt
  transferredAt_lt: BigInt
  transferredAt_gte: BigInt
  transferredAt_lte: BigInt
  transferredAt_in: [BigInt!]
  transferredAt_not_in: [BigInt!]
  tier: String
  tier_not: String
  tier_gt: String
  tier_lt: String
  tier_gte: String
  tier_lte: String
  tier_in: [String!]
  tier_not_in: [String!]
  tier_contains: String
  tier_contains_nocase: String
  tier_not_contains: String
  tier_not_contains_nocase: String
  tier_starts_with: String
  tier_starts_with_nocase: String
  tier_not_starts_with: String
  tier_not_starts_with_nocase: String
  tier_ends_with: String
  tier_ends_with_nocase: String
  tier_not_ends_with: String
  tier_not_ends_with_nocase: String
  tier_: Tier_filter
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_: User_filter
  collection: String
  collection_not: String
  collection_gt: String
  collection_lt: String
  collection_gte: String
  collection_lte: String
  collection_in: [String!]
  collection_not_in: [String!]
  collection_contains: String
  collection_contains_nocase: String
  collection_not_contains: String
  collection_not_contains_nocase: String
  collection_starts_with: String
  collection_starts_with_nocase: String
  collection_not_starts_with: String
  collection_not_starts_with_nocase: String
  collection_ends_with: String
  collection_ends_with_nocase: String
  collection_not_ends_with: String
  collection_not_ends_with_nocase: String
  collection_: Collection_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Nft_orderBy {
  id
  tokenID
  artworkID
  transferredAt
  tier
  owner
  collection
}

type OpenSaleApp {
  id: ID!
  isNative: Boolean!
  isActive: Boolean!
  tierIds: [String!]
  tierPrices: [String!]
}

input OpenSaleApp_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isNative: Boolean
  isNative_not: Boolean
  isNative_in: [Boolean!]
  isNative_not_in: [Boolean!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  tierIds: [String!]
  tierIds_not: [String!]
  tierIds_contains: [String!]
  tierIds_contains_nocase: [String!]
  tierIds_not_contains: [String!]
  tierIds_not_contains_nocase: [String!]
  tierPrices: [String!]
  tierPrices_not: [String!]
  tierPrices_contains: [String!]
  tierPrices_contains_nocase: [String!]
  tierPrices_not_contains: [String!]
  tierPrices_not_contains_nocase: [String!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum OpenSaleApp_orderBy {
  id
  isNative
  isActive
  tierIds
  tierPrices
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type PrivateSaleApp {
  id: ID!
  isNative: Boolean!
  isActive: Boolean!
  tierIds: [String!]
  tierPrices: [String!]
}

input PrivateSaleApp_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isNative: Boolean
  isNative_not: Boolean
  isNative_in: [Boolean!]
  isNative_not_in: [Boolean!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  tierIds: [String!]
  tierIds_not: [String!]
  tierIds_contains: [String!]
  tierIds_contains_nocase: [String!]
  tierIds_not_contains: [String!]
  tierIds_not_contains_nocase: [String!]
  tierPrices: [String!]
  tierPrices_not: [String!]
  tierPrices_contains: [String!]
  tierPrices_contains_nocase: [String!]
  tierPrices_not_contains: [String!]
  tierPrices_not_contains_nocase: [String!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum PrivateSaleApp_orderBy {
  id
  isNative
  isActive
  tierIds
  tierPrices
}

type Query {
  dao(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Dao
  daos(
    skip: Int = 0
    first: Int = 100
    orderBy: Dao_orderBy
    orderDirection: OrderDirection
    where: Dao_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Dao!]!
  controller(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Controller
  controllers(
    skip: Int = 0
    first: Int = 100
    orderBy: Controller_orderBy
    orderDirection: OrderDirection
    where: Controller_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Controller!]!
  adminOption(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AdminOption
  adminOptions(
    skip: Int = 0
    first: Int = 100
    orderBy: AdminOption_orderBy
    orderDirection: OrderDirection
    where: AdminOption_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AdminOption!]!
  user(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  collection(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Collection
  collections(
    skip: Int = 0
    first: Int = 100
    orderBy: Collection_orderBy
    orderDirection: OrderDirection
    where: Collection_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Collection!]!
  nft(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Nft
  nfts(
    skip: Int = 0
    first: Int = 100
    orderBy: Nft_orderBy
    orderDirection: OrderDirection
    where: Nft_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Nft!]!
  tier(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Tier
  tiers(
    skip: Int = 0
    first: Int = 100
    orderBy: Tier_orderBy
    orderDirection: OrderDirection
    where: Tier_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Tier!]!
  attribute(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Attribute
  attributes(
    skip: Int = 0
    first: Int = 100
    orderBy: Attribute_orderBy
    orderDirection: OrderDirection
    where: Attribute_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Attribute!]!
  openSaleApp(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OpenSaleApp
  openSaleApps(
    skip: Int = 0
    first: Int = 100
    orderBy: OpenSaleApp_orderBy
    orderDirection: OrderDirection
    where: OpenSaleApp_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OpenSaleApp!]!
  privateSaleApp(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PrivateSaleApp
  privateSaleApps(
    skip: Int = 0
    first: Int = 100
    orderBy: PrivateSaleApp_orderBy
    orderDirection: OrderDirection
    where: PrivateSaleApp_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PrivateSaleApp!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Subscription {
  dao(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Dao
  daos(
    skip: Int = 0
    first: Int = 100
    orderBy: Dao_orderBy
    orderDirection: OrderDirection
    where: Dao_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Dao!]!
  controller(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Controller
  controllers(
    skip: Int = 0
    first: Int = 100
    orderBy: Controller_orderBy
    orderDirection: OrderDirection
    where: Controller_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Controller!]!
  adminOption(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AdminOption
  adminOptions(
    skip: Int = 0
    first: Int = 100
    orderBy: AdminOption_orderBy
    orderDirection: OrderDirection
    where: AdminOption_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AdminOption!]!
  user(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  collection(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Collection
  collections(
    skip: Int = 0
    first: Int = 100
    orderBy: Collection_orderBy
    orderDirection: OrderDirection
    where: Collection_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Collection!]!
  nft(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Nft
  nfts(
    skip: Int = 0
    first: Int = 100
    orderBy: Nft_orderBy
    orderDirection: OrderDirection
    where: Nft_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Nft!]!
  tier(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Tier
  tiers(
    skip: Int = 0
    first: Int = 100
    orderBy: Tier_orderBy
    orderDirection: OrderDirection
    where: Tier_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Tier!]!
  attribute(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Attribute
  attributes(
    skip: Int = 0
    first: Int = 100
    orderBy: Attribute_orderBy
    orderDirection: OrderDirection
    where: Attribute_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Attribute!]!
  openSaleApp(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OpenSaleApp
  openSaleApps(
    skip: Int = 0
    first: Int = 100
    orderBy: OpenSaleApp_orderBy
    orderDirection: OrderDirection
    where: OpenSaleApp_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OpenSaleApp!]!
  privateSaleApp(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PrivateSaleApp
  privateSaleApps(
    skip: Int = 0
    first: Int = 100
    orderBy: PrivateSaleApp_orderBy
    orderDirection: OrderDirection
    where: PrivateSaleApp_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PrivateSaleApp!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Tier {
  id: ID!
  name: String!
  nativeID: String!
  collection: Collection!
  Nfts(skip: Int = 0, first: Int = 100, orderBy: Nft_orderBy, orderDirection: OrderDirection, where: Nft_filter): [Nft!]
  attributes(skip: Int = 0, first: Int = 100, orderBy: Attribute_orderBy, orderDirection: OrderDirection, where: Attribute_filter): [Attribute!]
}

input Tier_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  nativeID: String
  nativeID_not: String
  nativeID_gt: String
  nativeID_lt: String
  nativeID_gte: String
  nativeID_lte: String
  nativeID_in: [String!]
  nativeID_not_in: [String!]
  nativeID_contains: String
  nativeID_contains_nocase: String
  nativeID_not_contains: String
  nativeID_not_contains_nocase: String
  nativeID_starts_with: String
  nativeID_starts_with_nocase: String
  nativeID_not_starts_with: String
  nativeID_not_starts_with_nocase: String
  nativeID_ends_with: String
  nativeID_ends_with_nocase: String
  nativeID_not_ends_with: String
  nativeID_not_ends_with_nocase: String
  collection: String
  collection_not: String
  collection_gt: String
  collection_lt: String
  collection_gte: String
  collection_lte: String
  collection_in: [String!]
  collection_not_in: [String!]
  collection_contains: String
  collection_contains_nocase: String
  collection_not_contains: String
  collection_not_contains_nocase: String
  collection_starts_with: String
  collection_starts_with_nocase: String
  collection_not_starts_with: String
  collection_not_starts_with_nocase: String
  collection_ends_with: String
  collection_ends_with_nocase: String
  collection_not_ends_with: String
  collection_not_ends_with_nocase: String
  collection_: Collection_filter
  Nfts_: Nft_filter
  attributes_: Attribute_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Tier_orderBy {
  id
  name
  nativeID
  collection
  Nfts
  attributes
}

type User {
  id: ID!
  nfts(skip: Int = 0, first: Int = 100, orderBy: Nft_orderBy, orderDirection: OrderDirection, where: Nft_filter): [Nft!]!
  adminOf(skip: Int = 0, first: Int = 100, orderBy: AdminOption_orderBy, orderDirection: OrderDirection, where: AdminOption_filter): [AdminOption!]!
}

input User_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  nfts_: Nft_filter
  adminOf_: AdminOption_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum User_orderBy {
  id
  nfts
  adminOf
}

